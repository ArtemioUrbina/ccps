#include "ccps_gfx.h" // This is auto-generated by GFX

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  


#define	MAXSPRITES	256

typedef struct
{
	WORD	x;			// Sprite x position
	WORD	y;			// Sprite y position
	WORD	tile;		// Sprite tile

	// 0..4 CB[0..4] Palette ID used to render the tile
   // 5 X Flip Mirrored horizontally
   // 6 Y Flip Mirrored vertically
   // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
   // 8..11 XB[0..3] Horizontal size in tiles
   // 12..15 YB[0..3] Vertical size in tiles
	WORD	attributes;   	// Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

CPSA_REG WORD cpsa_reg[0x20] = {};
CPSB_REG WORD cpsb_reg[0x20] = {};

int vsyncCounter = 0;
int soundCounter = 0;
int someCounter = 0x6666;
int uinVARRRRRR;
const int mYcOnStT = 1;


static const Palette ryu = {0xF111 ,0xFFD9,0xFFB8,0xFE97,0xFC86,0xF965,0xF643,0xFb00,
   	                   0xFfff,0xFeec,0xFdca,0xFba8,0xFa87,0xF765,0xFf00,0x0000};

void setPalette(int page, int paletteID, const Palette* palette) {

   for (int j = 0 ; j < 16 ; j++) {
  	  palettes[paletteID].colors[j] = (*palette).colors[j];
   }

	// Palette control
   // bit 0: copy page 0 (sprites)
   // bit 1: copy page 1 (scroll1)
   // bit 2: copy page 2 (scroll2)
   // bit 3: copy page 3 (scroll3)
   // bit 4: copy page 4 (stars1)
   // bit 5: copy page 5 (stars2)
   cpsb_reg[0x30 / 2] =  1;

   // Set palette base
	cpsa_reg[0xa / 2] = (WORD)(((DWORD)palettes) >> 8);
}

//void drawRyu() {
//   setPalette(0, 2, &ryu);
//   Sprite* s = &sprites[0];
//   s->x = 220;
//   s->y = 100;
//   s->tile = 	4;
//   s->attributes = 2 |  0x5 << 12 | 0x3 << 8; // Use palette 2 dim 5+1x3+1 = 6x4 tiles
//
//   sprites[1].attributes	= 0xFF00; // Last sprite marker
//
//}

extern GFXShape helloworld;
extern Palette phelloworld;

void drawHW() {
  setPalette(0, 2, &phelloworld);
//  setPalette(0, 2, &ryu);
  int i = 0;
  for (; i < helloworld.numTiles; i++) {
     Sprite* s = &sprites[i];
     GFXShapeTile* t = &(helloworld.tiles[i]);
     s->x = 196 + t->x * 16;
     s->y = 100 + t->y * 16;
     s->tile = t->id;
     s->attributes = 2 ;//|  0x5 << 1 | 0x3 << 1; // Use palette 2 dim 5+1x3+1 = 6x4 tiles
  }
  sprites[i].attributes	= 0xFF00; // Last sprite marker

}

void onVSync() {

   // Enable layers
//   cpsb_reg[0x26 / 2] = 0x3 << 6 ;//| 0x3 << 0xc;
   // sprite = 6, scroll1=8, scroll2=a, scroll3=c
   // cpsb_reg[0x13] = 0x12CE;
   //*((WORD*)0x00800166) = 0x12CE;

//    drawRyu();
   drawHW();
   cpsa_reg[0] = (WORD)(((DWORD)sprites) >> 8);


   vsyncCounter++;
   if (vsyncCounter >= 60) {
   	uinVARRRRRR++;
   	vsyncCounter = 0;
   	soundCounter += 1;
   	*((char*)0x800180) = (0x22 + soundCounter);
   	
   } else {
   	*((char*)0x800180) = 0xFF;
   }
}

int run() {
	return 0;
}